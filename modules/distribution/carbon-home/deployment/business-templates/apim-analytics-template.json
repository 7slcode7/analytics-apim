{
   "templateGroup": {
      "uuid": "apim-analytics",
      "name": "APIM Analytics",
      "description": "Real Time Analytics of APIM",
      "ruleTemplates": [
         {
            "uuid": "apim-frequent-tier-limit-hitting-alert",
            "name": "APIM Frequent Tier Limit Hitting Alert",
            "description": "Alerts when a user or an application goes beyond the subscribed quota frequently",
            "type": "template",
            "instanceCount": "many",
            "script": "",
            "templates": [
               {
                  "type": "siddhiApp",
                  "content": "@App:name(\"APIM_FREQUENT_TIER_LIMIT_HITTING_ALERT\")\n@App:description(\"Alerts when a user or application goes beyond the subscribed quota frequently\")\n\n-- This stream definition is only to define the Aggregation. It does not consume the actual API request.\ndefine stream ThrottledOutStream(\n    meta_clientType string,\n    username string,\n    userTenantDomain string,\n    apiName string,\n    apiVersion string,\n    apiContext string,\n    apiCreator string,\n    apiCreatorTenantDomain string,\n    applicationId string,\n    applicationName string,\n    subscriber string,\t\n    throttledOutReason string,\n    gatewayType string,\n    throttledOutTimestamp long\n);\n\n--This aggregation definition is only for retrieving data. No data is actually aggregated from this.\n@store(type='rdbms', datasource='APIM_ANALYTICS_DB') \ndefine aggregation ApiThrottledOutAgg\nfrom ThrottledOutStream\nselect apiName,apiVersion,apiContext,apiCreator,apiCreatorTenantDomain,username,userTenantDomain,applicationId,applicationName,subscriber,count() as throttledOutCount,throttledOutReason,gatewayType\ngroup by apiContext,applicationId,throttledOutReason\naggregate by throttledOutTimestamp every seconds...year;\n\n@store(type = 'rdbms', datasource = 'APIM_ANALYTICS_DB')\ndefine table ApimAllAlert (type string, tenantDomain string, message string, severity int, alertTimestamp long);\n\n@PrimaryKey('userId', 'isSubscriber', 'isPublisher', 'isAdmin')\n@store(type = 'rdbms', datasource = 'APIM_ANALYTICS_DB')\ndefine table ApimAlertStakeholderInfo(userId string, alertTypes\tstring, emails\tstring, isSubscriber bool, isPublisher\tbool, isAdmin\tbool);\n\n@store(type = 'rdbms', datasource = 'APIM_ANALYTICS_DB')\ndefine table ApimTierLimitHittingAlert (subscriber string, apiCreator string, apiName string, applicationId string, applicationName string, apiCreatorTenantDomain string, userTenantDomain string, message string, severity int, alertTimestamp long);\n\n@sink(type=\"inMemory\", topic=\"APIM_EMAIL_NOTIFICATION\", @map(type='passThrough'))\ndefine stream EmailAlertStream (type string, message string, alertTimestamp\tstring, emails\tstring);\n\ndefine trigger DayTrigger at every 1 day;\n\nfrom DayTrigger \nselect currentTimeMillis() as currentTimestamp, (currentTimeMillis() - 24*60*60*1000) as endTimestamp\ninsert into TriggerInfoStream;\n\n--Gets the total trhottled out data for a day\n@info(name='requestsPerMinCountingQuery') \nfrom TriggerInfoStream as T join ApiThrottledOutAgg as TA\nwithin T.endTimestamp, T.currentTimestamp\n  per \"days\"\nselect apiName, apiVersion, applicationId, applicationName,apiCreator, apiCreatorTenantDomain,username,userTenantDomain,subscriber,throttledOutCount,throttledOutReason\ngroup by applicationId, apiContext, apiCreator, apiCreatorTenantDomain  \ninsert into ThrottledOutTriggerStream;\n\n--checks whether total throttled out count with the throttled out reson SUBSCRIPTION_LIMIT_EXCEEDED is higer than the specified value\n@info(name = 'TemporarySubscriberStream generating Query')\nfrom ThrottledOutTriggerStream[throttledOutReason == 'SUBSCRIPTION_LIMIT_EXCEEDED']\nselect apiCreator, apiName, apiVersion, applicationId, applicationName,apiCreatorTenantDomain,userTenantDomain, subscriber, throttledOutCount as numHits\ngroup by apiCreator,apiName,apiVersion, applicationId\nhaving numHits > ${numOfTierCrossing}\ninsert into TemporarySubscriberStream;\n\n--checks whether total throttled out count with the throttled out reson APPLICATION_LIMIT_EXCEEDED is higer than the specified value\n@info(name = 'TemporaryUserStream generating Query')\nfrom ThrottledOutTriggerStream[throttledOutReason == 'APPLICATION_LIMIT_EXCEEDED']\nselect username, apiCreator, apiName, apiVersion, applicationId, applicationName, \napiCreatorTenantDomain,userTenantDomain, subscriber, throttledOutCount as numHits\ngroup by username, apiName,apiVersion, applicationId\nhaving numHits > ${numOfTierCrossing}\ninsert into TemporaryUserStream;\n\n-- send to the alert stream specific to this scenario \n@info(name = 'Query generates TierLimitHittingAlertStream from SuppressedTemporarySubscriberStream')\nfrom TemporarySubscriberStream\nselect subscriber,ifThenElse(a.apiCreatorTenantDomain == 'carbon.super', str:concat(a.apiCreator, \"@carbon.super\"), a.apiCreator) as apiCreator, apiName, applicationId, applicationName, apiCreatorTenantDomain,userTenantDomain,str:concat('Application: ',applicationName,' frequently goes beyond the allocated quota when accessing API : ',apiName) as message,${severityLevel} as severity, (time:timestampInMilliseconds()) as alertTimestamp\ninsert into TierLimitHittingAlertStream;\n\n@info(name = 'Query generates TierLimitHittingAlertStream from SuppressedTemporaryUserStream')\nfrom TemporaryUserStream\nselect subscriber,ifThenElse(a.apiCreatorTenantDomain == 'carbon.super', str:concat(a.apiCreator, \"@carbon.super\"), a.apiCreator) as apiCreator, apiName, applicationId, applicationName, apiCreatorTenantDomain, userTenantDomain, str:concat(\"User \", username, \" frequently crosses the limit set when accessing \",apiName) as message, ${severityLevel} as severity, (time:timestampInMilliseconds()) as alertTimestamp\ninsert into TierLimitHittingAlertStream;\n\nfrom TierLimitHittingAlertStream\nselect \"FrequentTierLimitHitting\" as type, userTenantDomain as tenantDomain,message,severity,alertTimestamp\ninsert into ApimAllAlert;\n\n@info(name='Query inserts data to ApimTierLimitHittingAlert table')\nfrom TierLimitHittingAlertStream\nselect *\ninsert into ApimTierLimitHittingAlert;\n\n@info(name='Email generation query') \nfrom TierLimitHittingAlertStream#window.length(1) as TL join ApimAlertStakeholderInfo as ASI\non ((TL.subscriber == ASI.userId and true == ASI.isSubscriber ) or true == ASI.isAdmin )\nselect 'FrequentTierLimitHitting' as type ,\nifThenElse(str:contains(TL.message, 'Application frequently goes beyond the allocated quota'),str:concat(\"The application \", TL.applicationName, \" owned by \", TL.subscriber, \" frequently goes beyond the allocated quota when accessing the \", TL.apiName,\" API.\"),\nstr:concat(TL.message , \" Using the \", TL.applicationName, \" application owned by \",TL.subscriber, \".\")) as message, time:dateFormat(TL.alertTimestamp,'yyyy-MM-dd HH:mm:ss') as alertTimestamp,ASI.emails\nhaving  str:contains(ASI.alertTypes, 'FrequentTierLimitHitting')\ninsert into EmailAlertStream;\n"
               }
            ],
            "properties": {
               "numOfTierCrossing": {
                  "fieldName": "No of Tier Crossing",
                  "description": "Max Number of tier crossings for the given time window",
                  "defaultValue": "10"
               },
               "severityLevel": {
                  "fieldName": "Severity Level",
                  "description": " Severity level of the alert:(1:severe,2:moderate,3:mild)",
                  "defaultValue": "3"
               }
            }
         },
         {
            "uuid": "apim-health-availability-alert",
            "name": "APIM API Health Availability Alert",
            "description": "Monitors the Health of an API",
            "type": "template",
            "instanceCount": "many",
            "script": "",
            "templates": [
               {
                  "type": "siddhiApp",
                  "content": "@App:name(\"APIM_HEALTH_AVAILABILITY_ALERT\")\n@App:description(\"Determines the availablity and health of an api\")\n\n@source(type ='inMemory', topic = 'APIM_REQUEST_ALERT_INFO')\ndefine stream RequestAlertInfoStream (apiContext string,apiName string, apiVersion string, apiResourceTemplate string, apiMethod string, apiCreator string, apiCreatorTenantDomain string, requestTimestamp long, responseTime long, backendTime long, thresholdBackendTime long, thresholdResponseTime long,responseCode int );\n\n--Table Definitions\n@store(type = 'rdbms', datasource = 'APIM_ANALYTICS_DB')\ndefine table ApimAllAlert (type string, tenantDomain string, message string, severity int, alertTimestamp long);\n\n@primaryKey('tenantApiVersion')\n@store(type = 'rdbms', datasource = 'APIM_ANALYTICS_DB')\ndefine table ApimAlertTableResponseInfo (tenantApiVersion string, count int);\n\n@primaryKey('apiName','apiVersion','tenantDomain')\n@store(type = 'rdbms', datasource = 'APIM_ANALYTICS_DB')\ndefine table ApimApiAvailabilityInfo (apiName string,apiVersion string, apiCreator string , tenantDomain string, status string);\n\n@PrimaryKey('userId', 'isSubscriber', 'isPublisher', 'isAdmin')\n@store(type = 'rdbms', datasource = 'APIM_ANALYTICS_DB')\ndefine table ApimAlertStakeholderInfo(userId string, alertTypes\tstring, emails string, isSubscriber bool, isPublisher\tbool, isAdmin\tbool);\n\n@store(type = 'rdbms', datasource = 'APIM_ANALYTICS_DB')\ndefine table ApimApiHealthMonitorAlert(apiName string,apiVersion string,apiCreator string, apiCreatorTenantDomain string,\n message string, severity int, alertTimestamp long);\n\n@sink(type=\"inMemory\", topic=\"APIM_EMAIL_NOTIFICATION\", @map(type='passThrough'))\ndefine stream EmailAlertStream (type string, message string, alertTimestamp\tstring, emails string);\n\ndefine stream ApimAllAlertSummary (type string, tenantDomain string, message string, severity int, alertTimestamp long);\n\npartition with (apiContext of RequestAlertInfoStream)\nbegin\n    -- checks whether the response time is higher than the threshold response time continously for 5 times\n    from every e1=RequestAlertInfoStream[responseTime>thresholdResponseTime and thresholdResponseTime>0],e2=RequestAlertInfoStream[responseTime>thresholdResponseTime and thresholdResponseTime>0],e3=RequestAlertInfoStream[responseTime>thresholdResponseTime and thresholdResponseTime>0], e4=RequestAlertInfoStream[responseTime>thresholdResponseTime and thresholdResponseTime>0],e5=RequestAlertInfoStream[responseTime>thresholdResponseTime and thresholdResponseTime>0]\n    select e1.apiName,e1.apiVersion,e1.apiContext,e1.apiCreator,e1.apiCreatorTenantDomain,e1.thresholdResponseTime\n    insert into TempResponseTimeAlertStream;\n    \n    --checks whether the response code is between 500 - 600 to identify a server error\n     from every e1=RequestAlertInfoStream[responseCode>=500 and responseCode<600],e2=RequestAlertInfoStream[responseCode>=500 and responseCode<600],e3=RequestAlertInfoStream[responseCode>=500 and responseCode<600], e4=RequestAlertInfoStream[responseCode>=500 and responseCode<600],e5=RequestAlertInfoStream[responseCode>=500 and responseCode<600]\n    select e1.apiName,e1.apiVersion,e1.apiContext,e1.apiCreator,e1.apiCreatorTenantDomain \n    insert into TempResponseCodeAlertStream;\nend;\n\n@info(name='Query generates ApiHealthMonitorAlertStreamTemp with message for high response time alert') \nfrom TempResponseTimeAlertStream\nselect apiName,apiVersion, ifThenElse(apiCreatorTenantDomain == 'carbon.super', str:concat(apiCreator, \"@carbon.super\"), apiCreator) as apiCreator, apiCreatorTenantDomain, str:concat('Response time is higher than ' ,thresholdResponseTime, ' ms continuously for 5 or more responses.') as message, ${severityLevel} as severity, (time:timestampInMilliseconds()) as alertTimestamp\ninsert into ApiHealthMonitorAlertStreamTemp;\n\n@info(name='Query generates ApiHealthMonitorAlertStreamTemp with message for server error alert')\nfrom TempResponseCodeAlertStream\nselect apiName, apiVersion, ifThenElse(apiCreatorTenantDomain == 'carbon.super', str:concat(apiCreator, \"@carbon.super\"), apiCreator) as apiCreator, apiCreatorTenantDomain, 'Server error occurred continuously for 5 or more times.'  as message,{$severityLevel} as severity, (time:timestampInMilliseconds()) as alertTimestamp\ninsert into ApiHealthMonitorAlertStreamTemp;\n\n@info(name='Query generating TempallApimAlertStream') \nfrom ApiHealthMonitorAlertStreamTemp \nselect 'ApiHealthMonitor' as type, apiCreatorTenantDomain, str:concat('API:', apiName,' ',apiVersion, '-', message) as message ,${severityLevel} as severity, (time:timestampInMilliseconds()) as alertTimestamp\ninsert into TempallApimAlertStream;\n\n--inserts data into ApimAllAlertSummary, if the same alert was not generated for a time defined in #window.time\n@info(name='Query generates ApimAllAlertSummary') \nfrom TempallApimAlertStream#window.length(1) as TA left outer join ApimAllAlertSummary#window.time(${alertSupressTime}) as AAS\non TA.message == AAS.message\nselect TA.type,TA.apiCreatorTenantDomain as tenantDomain,TA.message,TA.severity,TA.alertTimestamp\nhaving AAS.message is null\ninsert into ApimAllAlertSummary;\n\n@info(name='Query inserts data to ApimApiHealthMonitorAler') \n from ApiHealthMonitorAlertStreamTemp#window.length(1) as AH left outer join ApimApiHealthMonitorAlert#window.time(${alertSupressTime}) as AM\non AH.apiName==AM.apiName and AH.apiVersion==AM.apiVersion and AH.message==AM.message\nselect AH.apiName,AH.apiVersion,AH.apiCreator,AH.apiCreatorTenantDomain,AH.message,AH.severity,AH.alertTimestamp\nhaving AM.apiName is null and AM.apiVersion is null and AM.message is null\ninsert into ApimApiHealthMonitorAlert;\n\n@info(name='Query inserts data to ApimAllAlert')\nfrom ApimAllAlertSummary \nselect type,tenantDomain,message as message,severity,alertTimestamp\ninsert into ApimAllAlert;\n\n@info(name='Query inserts data to ApimApiAvailability')\nfrom ApiHealthMonitorAlertStreamTemp\nselect apiName,apiVersion,apiCreator,apiCreatorTenantDomain as tenantDomain,message as status\nupdate or insert into ApimApiAvailabilityInfo \nset ApimApiAvailabilityInfo.status=status\non ApimApiAvailabilityInfo.apiName==apiName and ApimApiAvailabilityInfo.apiVersion==apiVersion and ApimApiAvailabilityInfo.tenantDomain==tenantDomain;\n\n@info(name='Query inserting data to ApimApiAvailability when there is no alert for a defined time')\nfrom RequestAlertInfoStream#window.length(1) as R left outer join ApiHealthMonitorAlertStreamTemp#window.time(${availablityChange}) as AHM\non R.apiName==AHM.apiName and R.apiVersion==AHM.apiVersion \nselect R.apiName as apiName,R.apiVersion as apiVersion,R.apiCreator as apiCreator,R.apiCreatorTenantDomain as tenantDomain,\"Available\" as status\nhaving AHM.apiName is null \nupdate or insert into ApimApiAvailabilityInfo\nset ApimApiAvailabilityInfo.status=status\non ApimApiAvailabilityInfo.apiName==apiName and ApimApiAvailabilityInfo.apiVersion==apiVersion and ApimApiAvailabilityInfo.apiCreator==apiCreator and ApimApiAvailabilityInfo.tenantDomain==tenantDomain;\n\n@info(name='Query inserting data to Alert Stream')\nfrom ApiHealthMonitorAlertStreamTemp#window.length(1) join ApimAlertStakeholderInfo\non ((ApiHealthMonitorAlertStreamTemp.apiCreator == ApimAlertStakeholderInfo.userId and true == ApimAlertStakeholderInfo.isPublisher ) or true == ApimAlertStakeholderInfo.isAdmin )\nselect 'ApiHealthMonitor' as type , str:concat('API:', apiName,' ',apiVersion, '-', message) as message, time:dateFormat(ApiHealthMonitorAlertStreamTemp.alertTimestamp,'yyyy-MM-dd HH:mm:ss') as alertTimestamp, ApimAlertStakeholderInfo.emails\nhaving str:contains(ApimAlertStakeholderInfo.alertTypes, 'ApiHealthMonitor')\ninsert into EmailAlertStream;"
               }
            ],
            "properties": {
               "severityLevel": {
                  "fieldName": "Severity Level",
                  "description": "Severity level of the alert:(1:severe,2:moderate,3:mild)",
                  "defaultValue": "2"
               },
               "alertSupressTime": {
                  "fieldName": "Alert Suppression period",
                  "description": "Same alert will be sent only once within this time period",
                  "defaultValue": "30 minute"
               },
               "availablityChange": {
                  "fieldName": "Time interval for API availability status change",
                  "description": "Time duration taken to recheck and change the availability of an API ",
                  "defaultValue": "5 minute"
               }
            }
         },
         {
            "uuid": "apim-unusual-ip-access-alert",
            "name": "APIM Unusual IP Access Alert",
            "description": "Monitoring API health",
            "type": "template",
            "instanceCount": "many",
            "script": "",
            "templates": [
               {
                  "type": "siddhiApp",
                  "content": "@App:name(\"APIM_UNUSUAL_IP_ACCESS_ALERT\")\n@App:description(\"Alerts if an access from a strange ip is detected\")\n\n@source(type='inMemory' , topic='APIM_REQUEST')\ndefine stream Request (meta_clientType string, applicationConsumerKey string, applicationName string, applicationId string, applicationOwner string, apiContext string,apiName string, apiVersion string, apiResourcePath string, apiResourceTemplate string, apiMethod string, apiCreator string, apiCreatorTenantDomain string, apiTier string, apiHostname string, username string, userTenantDomain string, userIp string, userAgent string, requestTimestamp long, throttledOut bool, responseTime long, serviceTime long, backendTime long, responseCacheHit bool, responseSize long, protocol string, responseCode int, destination string, securityLatency long, throttlingLatency long, requestMediationLatency long, responseMediationLatency long, backendLatency long, otherLatency long, gatewayType string, label string);\n\n--Table Definitions\n@store(type = 'rdbms', datasource = 'APIM_ANALYTICS_DB')\ndefine table ApimAllAlert (type string, tenantDomain string, message string, severity int, alertTimestamp long);\n\n@store(type = 'rdbms', datasource = 'APIM_ANALYTICS_DB')\ndefine table ApimIPAccessAbnormalityAlert (type string, message string, severity int, ip string, applicationName string, applicationOwner string, username string,tenantDomain string, requestTimestamp long, alertTimestamp long);\n\n@PrimaryKey('applicationConsumerKey','ip')\n@store(type = 'rdbms', datasource = 'APIM_ANALYTICS_DB')\ndefine table ApimIPAccessSummary (username string, applicationConsumerKey string, ip string, lastAccessedDate long) ;\n\n@PrimaryKey('applicationConsumerKey','username')\n@store(type = 'rdbms', datasource = 'APIM_ANALYTICS_DB')\ndefine table ApimIPAccessAlertCount (username string, applicationConsumerKey string, requestCount long) ;\n\n@PrimaryKey('userId', 'isSubscriber', 'isPublisher', 'isAdmin')\n@store(type = 'rdbms', datasource = 'APIM_ANALYTICS_DB')\ndefine table ApimAlertStakeholderInfo(userId string, alertTypes\tstring, emails\tstring, isSubscriber bool, isPublisher\tbool, isAdmin\tbool);\n\n@sink(type=\"inMemory\", topic=\"APIM_EMAIL_NOTIFICATION\", @map(type='passThrough'))\ndefine stream EmailAlertStream (type string, message string, alertTimestamp\tstring, emails\tstring);\n\n@info(name = 'Query generates TempStream')\nfrom Request[applicationConsumerKey == ApimIPAccessSummary.applicationConsumerKey in ApimIPAccessSummary]#window.length(1) as api left outer join ApimIPAccessSummary as ais\non api.applicationConsumerKey == ais.applicationConsumerKey and api.userIp==ais.ip\nselect api.applicationConsumerKey as applicationConsumerKey, api.userTenantDomain as userTenantDomain, api.applicationName as applicationName ,  api.applicationOwner as applicationOwner,  api.username as username, api.userIp as requestHostName, ais.ip as ip, api.requestTimestamp, ais.lastAccessedDate as lastAccessedDate, count() as count \ninsert into TempStream;\n\n@info(name = 'Query generates NewConsumerKeyStream')\nfrom Request[not (applicationConsumerKey == ApimIPAccessSummary.applicationConsumerKey in ApimIPAccessSummary)]\nselect username, applicationConsumerKey, userIp as ip, requestTimestamp as lastAccessedDate, count() as count\ninsert into NewConsumerKeyStream;\n\n--updates the IPAccessSummary table if is a new consumerKey\n@info(name = 'Query inserts data to DB Table : ApimIPAccessSummary')\nfrom NewConsumerKeyStream\nselect username, applicationConsumerKey, ip, lastAccessedDate\nupdate or insert into ApimIPAccessSummary\non ApimIPAccessSummary.applicationConsumerKey==applicationConsumerKey and ApimIPAccessSummary.ip==ip;\n\n-- Adding the alert count\n@info(name = 'Query inserts data to DB Table : ApimIPAccessAlertCount')\nfrom NewConsumerKeyStream\nselect username, applicationConsumerKey, count as requestCount\nupdate or insert into ApimIPAccessAlertCount\non ApimIPAccessAlertCount.username == username and ApimIPAccessAlertCount.applicationConsumerKey==applicationConsumerKey;\n\n/*\n    all fields will have value if the username and applicationConsumerKey already exists\n    exUsername and exConsumerKey will be null if it is a new user and newUserStream is derived based on that\n*/\n@info(name='Query generates ExistingUserStream') \nfrom TempStream as ts left outer join ApimIPAccessAlertCount as iaac\non ts.username==iaac.username and ts.applicationConsumerKey == iaac.applicationConsumerKey \nselect ts.applicationConsumerKey as applicationConsumerKey, ts.userTenantDomain, ts.applicationName , ts.applicationOwner , ts.username as username, ts.requestHostName as requestHostName, ts.ip as ip, ts.requestTimestamp, ts.lastAccessedDate as lastAccessedDate, (ts.count + iaac.requestCount) as requestCount,iaac.username as exUsername, iaac.applicationConsumerKey as exConsumerKey\ninsert into ExistingUserStream;\n\n--checks whether the username is new\n@info(name='query generates new user stream') \nfrom ExistingUserStream[exUsername  is null]\nselect ts.applicationConsumerKey as applicationConsumerKey, ts.userTenantDomain, ts.applicationName , ts.applicationOwner , ts.username as username, ts.requestHostName as requestHostName, ts.ip as ip, ts.requestTimestamp, ts.lastAccessedDate as lastAccessedDate, count() as requestCount\ninsert into NewUserStream;\n\n@info(name='query inserts data to DB table : ApimIPAccessAlertCount') \nfrom NewUserStream\nselect username, applicationConsumerKey, requestCount\nupdate or insert into ApimIPAccessAlertCount \nset ApimIPAccessAlertCount.requestCount = requestCount\non ApimIPAccessAlertCount.username == username and ApimIPAccessAlertCount.applicationConsumerKey==applicationConsumerKey;\n\n@info(name='query inserts data to DB table : ApimIPAccessSummary')\nfrom NewUserStream\nselect username, applicationConsumerKey, requestHostName as ip, requestTimestamp as lastAccessedDate\nupdate or insert into ApimIPAccessSummary\non ApimIPAccessSummary.applicationConsumerKey==applicationConsumerKey and ApimIPAccessSummary.ip==ip;\n\n/*\n    if the username  and applicatioConsumerkey already exists it increments the request count for the username.\n    exUsername will not be null if it is an existing user\n*/\n@info(name = 'query update or insert data to ApimIPAccessAlertCount')\nfrom ExistingUserStream[not (exUsername  is null)]\nselect username, applicationConsumerKey, requestCount\nupdate or insert into ApimIPAccessAlertCount\nset ApimIPAccessAlertCount.requestCount=requestCount\non ApimIPAccessAlertCount.username == username and ApimIPAccessAlertCount.applicationConsumerKey==applicationConsumerKey;\n\n/*\n    if a requestCount from particular user has reached the threshold limit \n    and if a new ip is detected from the particular username and applicationConsumerKey\n    Note: ip will be null if its a new ip from the user\n*/ \n@info(name = 'query generates NewIPDetectedStream')\nfrom ExistingUserStream[ip is null and requestCount > ${minCount}]\nselect *\ninsert into NewIPDetectedStream;\n\n@info(name = 'query generates AlertIPAccessAbnormalityStream')\nfrom NewIPDetectedStream\nselect \"UnusualIPAccess\" as type, \"A request from a new IP detected.\" as message,${severityLevel} as severity, requestHostName as ip, applicationName, applicationOwner, username, userTenantDomain as tenantDomain, requestTimestamp,(time:timestampInMilliseconds()) as alertTimestamp\ninsert into AlertIpAccessAbnormalityStream;\n\n@info(name = 'query inserts data to ApimIPAccessSummaryTable')\nfrom NewIPDetectedStream\nselect username, applicationConsumerKey, requestHostName as ip, requestTimestamp as lastAccessedDate\nupdate or insert into ApimIPAccessSummary\non ApimIPAccessSummary.applicationConsumerKey==applicationConsumerKey and ApimIPAccessSummary.ip==ip;\n\n-- Check if the request for the IP is received after the threshold time gap\n@info(name = 'query generates CheckAbnormalTimeBetweenAccessStream ')\nfrom ExistingUserStream[(not (ip is null)) and requestCount > ${minCount}]\nselect requestHostName, applicationConsumerKey, applicationName, applicationOwner, (requestTimestamp - lastAccessedDate) as timeBetweenAccess, requestTimestamp, username, userTenantDomain as tenantDomain, lastAccessedDate\ninsert into CheckAbnormalTimeBetweenAccessStream;\n\n@info(name = 'query genererates AbnormalTimeBetweenAccessStream')\nfrom CheckAbnormalTimeBetweenAccessStream[timeBetweenAccess > ${mdbLastAccess}]\nselect *\ninsert into AbnormalTimeBetweenAccessStream;\n\n@info(name = 'query generates AlertIpAccessAbnormalityStream')\nfrom AbnormalTimeBetweenAccessStream\nselect \"UnusualIPAccess\" as type, \"A request from an old IP detected.\" as message, ${severityLevel} as severity, requestHostName as ip, applicationName, applicationOwner, username,tenantDomain , requestTimestamp,(time:timestampInMilliseconds()) as alertTimestamp\ninsert into AlertIpAccessAbnormalityStream;\n\n-- Send all the alerts to the Global Alert Stream\n@info(name = 'query inserts data to DB table ApimAllAlert')\nfrom AlertIpAccessAbnormalityStream\nselect type, tenantDomain, str:concat(\"A request from a \", ifThenElse(str:contains(message, 'old'), 'old','new'), \" IP (\", ip, \") detected by user:\" , username,  \" using application:\", applicationName, \" owned by \", applicationOwner, \".\") as message, severity, (time:timestampInMilliseconds()) as alertTimestamp\ninsert into ApimAllAlert;\n\n@info(name='query inserts data to DB table ApimIPAccessAbnormalityAlert') \nfrom AlertIpAccessAbnormalityStream\nselect *\ninsert into ApimIPAccessAbnormalityAlert;\n\n-- Update the request time for the lastAccessDate\n@info(name = 'query updates ApimIPAccessSummary Table')\nfrom CheckAbnormalTimeBetweenAccessStream[timeBetweenAccess > 1 day]\nselect username, applicationConsumerKey, requestHostName as ip, requestTimestamp as lastAccessedDate\nupdate or insert into ApimIPAccessSummary\nset ApimIPAccesSummary.lastAccessedDate=lastAccessedDate on\nApimIPAccessSummary.applicationConsumerKey == applicationConsumerKey and ApimIPAccessSummary.ip == ip;\n\nfrom AlertIpAccessAbnormalityStream#window.length(1) join ApimAlertStakeholderInfo as ASI\non ((AlertIpAccessAbnormalityStream.applicationOwner == ASI.userId and true == ASI.isSubscriber ) or true == ASI.isAdmin )\nselect 'UnusualIPAccess' as type , str:concat(\"A request from a \", ifThenElse(str:contains(message, 'old'), 'old','new'), \" IP (\", ip, \") detected by user:\" , AlertIpAccessAbnormalityStream.username,  \" using application:\", applicationName, \" owned by \", applicationOwner, \".\") as message, time:dateFormat(AlertIpAccessAbnormalityStream.alertTimestamp,'yyyy-MM-dd HH:mm:ss') as alertTimestamp, ASI.emails\nhaving  str:contains(ASI.alertTypes, 'UnusualIPAccess')\ninsert into EmailAlertStream;\n"
               }
            ],
            "properties": {
               "minCount": {
                  "fieldName": "Minimum Number of Request",
                  "description": "Minimum number of request that has to be sent by user to send alert",
                  "defaultValue": "100"
               },
               "severityLevel": {
                  "fieldName": "Severity Level",
                  "description": "Severity level of the alert:(1:severe,2:moderate,3:mild)",
                  "defaultValue": "2"
               },
               "mdbLastAccess": {
                  "fieldName": "Maximum Days Between Last Access",
                  "description": "Maximum days between Last access from the hostname to the latest",
                  "defaultValue": "30"
               }
            }
         }
      ]
   }
}